use crate::utils::{blocks_to_bits, bits_to_block, bitwise_right_shift, Block, block_xor};

fn gmul(x: Block, y: Block) -> Block {
    let mut result: Block = [0; 16];
    let mut accumulator: Block = y;
    let x_bits = blocks_to_bits(x);
    for i in 0..128 {
        if x_bits[i] == 1 {
            result = block_xor(result, accumulator);
        } 
        accumulator = mulx(accumulator);
    }
    result
}

#[test]
fn gmul00() {
    let x: Block = [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    let y: Block = [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    let expected: Block = [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    assert(gmul(x, y) == expected);
}

#[test]
fn gmul01() {
    let x: Block = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01];
    let y: Block = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01];
    let expected: Block = [0xe6, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03];
    print(gmul(x, y));
    print(expected);
    assert(gmul(x, y) == expected);
}
#[test]
fn gmul02() {
    let X = [0xaa, 0xe0, 0x69, 0x92, 0xac, 0xbf, 0x52, 0xa3, 0xe8, 0xf4, 0xa9, 0x6e, 0xc9, 0x30, 0x0b, 0xd7];
    let Y = [0x98, 0xe7, 0x24, 0x7c, 0x07, 0xf0, 0xfe, 0x41, 0x1c, 0x26, 0x7e, 0x43, 0x84, 0xb0, 0xf6, 0x00];

    let expected = [0x90, 0xe8, 0x73, 0x15, 0xfb, 0x7d, 0x4e, 0x1b, 0x40, 0x92, 0xec, 0x0c, 0xbf, 0xda, 0x5d, 0x7d];
    assert(gmul(X, Y) == expected);
}


/// Multiplication of the binary extension field by x
/// right shifts a block by one bit
/// if the msb is one, then the 8 most LSBs are XORed with 0xE1
/// this 0xE1 is the the hex rep of 11100001, which represents 
/// the polynomial 1 + x + x^2 + x^7
fn mulx(block: Block) -> Block {
    let mut bits = blocks_to_bits(block);
    let result_bits = bitwise_right_shift(bits);
    let mut bytes = bits_to_block(result_bits);
    if bits[127] == 1 {
        bytes[0] = bytes[0] ^ 0xE1;
    }
    bytes
}

#[test]
fn test_mulx() {
    let input: Block = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01];
    let expected: Block = [0xE1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    assert(mulx(input) == expected);
}