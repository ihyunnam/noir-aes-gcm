use crate::utils::{Stream, Block, stream_to_block, block_to_stream};
use crate::gctr::{gctr, increment_32};
use crate::ghash::ghash;
use crate::aes::aes;

pub fn aes_gcm(key: Stream, plaintext: Stream, iv: [u8; 12], aad: Stream) -> (Stream, Stream) {

    // step 1: generate hashkey as encryption of a zero block with AES
    let zero_block: Block = [[0; 4]; 4];
    let hashkey = block_to_stream(aes(zero_block, key));

    // step 2: generate jO as iv || 0 ^{31} || 1 where || is concatenation
    let mut j0 = [0; 16];
    for i in 0..12 {
        j0[i] = iv[i];
    }
    j0[15] = 1;
    let j0_block = stream_to_block(j0);

    // step 3: Let C=GCTRK(inc32(J0), P).
    let C = gctr(key, increment_32(j0_block), plaintext);
    // Define a block, S, as follows:
    // A is 16 bytes, 128 bits, C is 16 bytes, 128 bits, then two 64 bit numbers is 16 bytes so 3 16 byte blocks
    let mut S = [[0; 16]; 3];
    S[0] = aad;
    S[1] = C;
    S[2] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,];
    let res = ghash(hashkey, S);
    // S = GHASHH (A || 0v || C || 0u || [len(A)]64 || [len(C)]64). 
    let T = gctr(key, j0_block, res);
    // // fn gctr(key: Stream, initial_counter_block: Block, plaintext: Stream) -> Stream {
    (C, T)
}

#[test]
fn test_aes_gcm() {
    let key = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    let plainText = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    let iv = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    let aad = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    let expected_output = [0x03, 0x88, 0xda, 0xce, 0x60, 0xb6, 0xa3, 0x92, 0xf3, 0x28, 0xc2, 0xb9, 0x71, 0xb2, 0xfe, 0x78];
    let (ciphertext, _tag) = aes_gcm(key, plainText, iv, aad);
    assert(ciphertext == expected_output);
}

#[test]
fn test_aes_gcm_2() {
    let key = [0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31];
    let iv = [0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31];
    let msg = [0x74, 0x65, 0x73, 0x74, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30];
    let aad = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    let ct = [0x29, 0x29, 0xd2, 0xbb, 0x1a, 0xe9, 0x48, 0x04, 0x40, 0x2b, 0x8e, 0x77, 0x6e, 0x0d, 0x33, 0x56];
    let (ciphertext, _tag) = aes_gcm(key, msg, iv, aad);
    assert(ciphertext == ct);
}